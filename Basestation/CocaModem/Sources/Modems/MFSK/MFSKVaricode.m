//
//  MFSKVaricode.m
//  cocoaModem 2.0
//
//  Created by Kok Chen on 1/30/07.
	#include "Copyright.h"

#import "MFSKVaricode.h"


@implementation MFSKVaricode

//  The following table is taken from
//  http://sharon.esrac.ele.tue.nl/mirrors/zl1bpu/MFSK/Varicode.txt 

static char *mfskTable[] = {
		"11101011100",      // <NUL>
		"11101100000",      // <SOH>
		"11101101000",      // <STX>
		"11101101100",      // <ETX>
		"11101110000",      // <EOT>
		"11101110100",      // <ENQ>
		"11101111000",      // <ACK>
		"11101111100",      // <BEL>
		"10101000",			// <BS>
		"11110000000",      // <TAB>
		"11110100000",      // <LF>
		"11110101000",      // <VT>
		"11110101100",      // <FF>
		"10101100",			// <CR>
		"11110110000",      // <SO>
		"11110110100",      // <SI>
		"11110111000",      // <DLE>
		"11110111100",      // <DC1>
		"11111000000",      // <DC2>
		"11111010000",      // <DC3>
		"11111010100",      // <DC4>
		"11111011000",      // <NAK>
		"11111011100",      // <SYN>
		"11111100000",      // <ETB>
		"11111101000",      // <CAN>
		"11111101100",      // <EM>
		"11111110000",      // <SUB>
		"11111110100",      // <ESC>
		"11111111000",      // <FS>
		"11111111100",      // <GS>
		"100000000000",     // <RS>
		"101000000000",     // <US>
		"100",				//  <SPACE>
		"111000000",		// !
		"111111100",		// "
		"1011011000",		// #		
		"1010101000",		// $
		"1010100000",		// %
		"1000000000",		// &
		"110111100",		// '
		"111110100",		// (
		"111110000",		// )	
		"1010110100",		// *
		"111100000",		// +
		"10100000",			// ,
		"111011000",		// -
		"111010100",		// .
		"111101000",		// /
		"11100000",			// 0
		"11110000",			// 1
		"101000000",		// 2
		"101010100",		// 3
		"101110100",		// 4
		"101100000",		// 5
		"101101100",		// 6
		"110100000",		// 7
		"110000000",		// 8
		"110101100",		// 9
		"111101100",		// :		
		"111111000",		// ,
		"1011000000",		// <
		"111011100",		// =
		"1010111100",		// >
		"111010000",		// ?
		"1010000000",		// @
		"10111100",			// A
		"100000000",		// B
		"11010100",			// C
		"11011100",			// D
		"10111000",			// E
		"11111000",			// F
		"101010000",		// G
		"101011000",		// H
		"11000000",			// I
		"110110100",		// J
		"101111100",		// K
		"11110100",			// L
		"11101000",			// M
		"11111100",			// N
		"11010000",			// O
		"11101100",			// P
		"110110000",		// Q		
		"11011000",			// R
		"10110100",			// S
		"10110000",			// T
		"101011100",		// U
		"110101000",		// V		
		"101101000",		// W
		"101110000",		// X
		"101111000",		// Y
		"110111000",		// Z
		"1011101000",		// [
		"1011010000",		// (backslash) 
		"1011101100",		// ]
		"1011010100",		// ^
		"1010110000",		// _
		"1010101100",		// `
		"10100",			// a
		"1100000",			// b		
		"111000",			// c
		"110100",			// d
		"1000",				// e
		"1010000",			// f
		"1011000",			// g		
		"110000",			// h
		"11000",			// i
		"10000000",			// j
		"1110000",			// k
		"101100",			// l
		"1000000",			// m
		"11100",			// n
		"10000",			// o
		"1010100",			// p
		"1111000",			// q
		"100000",			// r
		"101000",			// s
		"1100",				// t
		"111100",			// u
		"1101100",			// v
		"1101000",			// w
		"1110100",			// x
		"1011100",			// y
		"1111100",			// z
		"1011011100",		// {
		"1010111000",		// |
		"1011100000",		// }
		"1011110000",		// ~
		"101010000000",	// <DEL>
		"101010100000",	// ?
		"101010101000",	// Ç
		"101010101100",	// Ç
		"101010110000",	// É
		"101010110100",	// Ñ
		"101010111000",	// Ö
		"101010111100",	// Ü
		"101011000000",	// á
		"101011010000",	// à
		"101011010100",	// â
		"101011011000",	// ä
		"101011011100",	// ã
		"101011100000",	// å
		"101011101000",	// ç
		"101011101100",	// Z
		"101011110000",	// è
		"101011110100",	// ê
		"101011111000",	// ë
		"101011111100",	// í
		"101100000000",	// ì
		"101101000000",	// î
		"101101010000",	// ï
		"101101010100",	// ñ
		"101101011000",	// ó
		"101101011100",	// ò
		"101101100000",	// ô
		"101101101000",	// ö
		"101101101100",	// õ
		"101101110000",	// ú
		"101101110100",	// ù
		"101101111000",	// z
		"101101111100",	// ü
		"1011110100",		//  
		"1011111000",		// °
		"1011111100",		// ¢
		"1100000000",		// £
		"1101000000",		// §
		"1101010000",		// •
		"1101010100",		// ¶
		"1101011000",		// ß
		"1101011100",		// ®
		"1101100000",		// ©
		"1101101000",		// ™
		"1101101100",		// ´
		"1101110000",		// ¨
		"1101110100",		// ≠
		"1101111000",		// Æ
		"1101111100",		// Ø
		"1110000000",		// ∞
		"1110100000",		// ±
		"1110101000",		// ≤
		"1110101100",		// ≥
		"1110110000",		// ¥
		"1110110100",		// µ
		"1110111000",		// ∂
		"1110111100",		// ∑
		"1111000000",		// ∏
		"1111010000",		// π
		"1111010100",		// ∫
		"1111011000",		// ª
		"1111011100",		// º
		"1111100000",		// Ω
		"1111101000",		// æ
		"1111101100",		// ø
		"1111110000",		// ¿
		"1111110100",		// ¡
		"1111111000",		// ¬
		"1111111100",		// √
		"10000000000",		// ƒ
		"10100000000",		// ≈
		"10101000000",		// ∆
		"10101010000",		// «
		"10101010100",		// »
		"10101011000",		// …
		"10101011100",		//  
		"10101100000",		// À
		"10101101000",		// Ã
		"10101101100",		// Õ
		"10101110000",		// Œ
		"10101110100",		// œ
		"10101111000",     // –
		"10101111100",     // —
		"10110000000",     // “
		"10110100000",     // ”
		"10110101000",     // ‘
		"10110101100",     // ’
		"10110110000",     // ÷
		"10110110100",     // ◊
		"10110111000",     // ÿ
		"10110111100",     // Ÿ
		"10111000000",     // ⁄
		"10111010000",     // €
		"10111010100",     // ‹
		"10111011000",     // ›
		"10111011100",     // ﬁ
		"10111100000",     // ﬂ
		"10111101000",     // ‡
		"10111101100",     // ·
		"10111110000",     // ‚
		"10111110100",     // „
		"10111111000",     // ‰
		"10111111100",     // Â
		"11000000000",     // Ê
		"11010000000",     // Á
		"11010100000",     // Ë
		"11010101000",     // È
		"11010101100",     // Í
		"11010110000",     // Î
		"11010110100",     // Ï
		"11010111000",     // Ì
		"11010111100",     // Ó
		"11011000000",     // Ô
		"11011010000",     // 
		"11011010100",     // Ò
		"11011011000",     // Ú
		"11011011100",     // Û
		"11011100000",     // Ù
		"11011101000",     // ı
		"11011101100",     // ˆ
		"11011110000",     // ˜
		"11011110100",     // ¯
		"11011111000",     // ˘
		"11011111100",     // ˙
		"11100000000",     // ˚
		"11101000000",     // n
		"11101010000",     // ˝
		"11101010100",     // ˛
		"11101011000",     // ˇ
} ;

- (id)init
{
	char *stopRemoved[256], *string ;
	int i ;
	
	self = [ super init ] ;
	
	if ( self ) {
		past = -1 ;
		//  remove the stop bits (trailing zeros) from the codes, redundant for decoding tables
		for ( i = 0; i < 256; i++ ) {
			string = (char*)malloc( 16*sizeof( char ) ) ;
			strcpy( string, mfskTable[i] ) ;
			string[ strlen( string )-2 ] = 0 ;
			stopRemoved[i] = string ;
		}		
		[ self useCode:stopRemoved ] ;
		for ( i = 255; i >= 0; i-- ) free( stopRemoved[i] ) ;
	}
	return self ;
}

//  unlike the PSK31 Varicode, do not strip an extra LSB since MFSK Varicode allows more than two zeros in a row
//  after stripping the usual two stop bits (a pair of zeros), the next LSB bit in PSK31 is always a 1, but not so with MFSK.
- (void)useCode:(char**)code
{
	int i, n ;
	char *str, *t ;
	
	for ( i = 0; i < 2048; i++ ) varicode[i] = -1 ;
	for ( i = 0; i < 256; i++ ) {
		str = code[i] ;
		n = 0 ;
		while ( *str ) {
			n = n*2 + ( ( *str == '1' ) ? 1 : 0 ) ;
			str++ ;
		}
		varicode[n] = i ;
	}
	for ( i = 0; i < 256; i++ ) {
		str = code[i] ;
		t = encoding[i].bits ;
		encoding[i].length = strlen( str ) + 2 ;
		while ( *str ) *t++ = ( *str++ == '0' ) ? 0 : 1 ;
		*t++ = 0 ;
		*t++ = 0 ;
	}
}

- (int)decode:(int)n
{	
	int ascii ;
	
	//  remove trailing zeros bits
	n >>= 2 ;
	if ( n & ( ~0x7ff ) ) return 0 ;
	ascii = varicode[n] ;
	
	if ( ascii > 255 ) ascii = -1 ;

	if ( ( past == '\r' && ascii == '\n' ) || ( past == '\n' && ascii == '\r' ) ) return -1 ;

	past = ascii ;
	if ( ascii == '\r' ) return '\n' ;
	
	return ascii ;
}

- (const char*)encode:(int)ascii
{
	return mfskTable[ascii&0xff] ;
}


@end
